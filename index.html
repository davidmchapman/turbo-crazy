<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Turbo-Crazy Drawing App</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      box-sizing: border-box;
      background: #111;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    *, *::before, *::after {
      box-sizing: inherit;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    /* Top control bar */
    #controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.5rem 1rem;
      background: #222;
      border-bottom: 1px solid #333;
      flex: 0 0 auto;
      flex-wrap: wrap;
    }

    #controls button {
      padding: 0.4rem 0.8rem;
      background: #3a8fff;
      border: none;
      border-radius: 4px;
      color: white;
      font-weight: 500;
      cursor: pointer;
      font-size: 0.9rem;
    }

    #controls button:hover {
      background: #2d75d1;
    }

    #controls button.mode-active {
      background: #4caf50;
    }

    #controls button.mode-active:hover {
      background: #3d8e41;
    }

    #controls label {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.9rem;
      white-space: nowrap;
    }

    #bgSlider {
      width: 140px;
    }

    #hint {
      margin-left: auto;
      font-size: 0.8rem;
      opacity: 0.7;
      white-space: nowrap;
    }

    #fpsCounter {
      font-size: 0.8rem;
      opacity: 0.7;
      white-space: nowrap;
      margin-left: 0.75rem;
    }

    @media (max-width: 900px) {
      #hint {
        flex-basis: 100%;
        margin-left: 0;
      }
    }

    /* Main area: left path panel + canvas + right palette panel */
    #main {
      flex: 1 1 auto;
      min-height: 0;
      display: flex;
      overflow-x: auto; /* if window gets tiny, allow horizontal scroll */
    }

    /* Left path panel: fixed width */
    #pathPanel {
      flex: 0 0 220px;
      width: 220px;
      min-width: 220px;
      background: #1a1a1a;
      border-right: 1px solid #333;
      padding: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    #pathPanelHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      font-size: 0.95rem;
      font-weight: 600;
    }

    #addPathBtn {
      padding: 0.2rem 0.6rem;
      font-size: 0.85rem;
      background: #4caf50;
    }

    #addPathBtn:hover {
      background: #3d8e41;
    }

    #pathList {
      flex: 1 1 auto;
      overflow-y: auto;
      padding-right: 0.25rem;
    }

    .path-item {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 0.25rem;
      padding: 0.25rem 0.35rem;
      border-radius: 4px;
      font-size: 0.85rem;
      cursor: pointer;
      margin-bottom: 0.15rem;
      background: #242424;
    }

    .path-item.selected {
      background: #34548a;
    }

    .path-main {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
    }

    .path-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.25rem;
    }

    .path-name {
      font-weight: 600;
    }

    .path-meta {
      font-size: 0.75rem;
      opacity: 0.8;
    }

    .delete-path-btn {
      border: none;
      background: transparent;
      color: #ddd;
      font-size: 0.9rem;
      cursor: pointer;
      padding: 0.1rem 0.25rem;
    }

    .delete-path-btn:hover {
      color: #ff7676;
    }

    .path-actions-container {
      display: flex;
      gap: 0.75rem;
      margin-top: 0.15rem;
      align-items: flex-start;
    }

    .path-speed-slider-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.3rem;
      flex-shrink: 0;
      padding-left: 0.5rem;
      border-left: 1px solid #333;
    }

    .path-speed-slider-label {
      font-size: 0.65rem;
      color: #aaa;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .path-speed-slider {
      width: 60px;
      height: 100px;
      -webkit-appearance: slider-vertical;
      appearance: slider-vertical;
      writing-mode: bt-lr; /* IE */
      direction: rtl;
    }

    .path-speed-value {
      font-size: 0.7rem;
      color: #ccc;
      min-height: 1.2em;
    }

    .path-effects-section {
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px solid #333;
    }

    .path-effects-title {
      font-size: 0.7rem;
      font-weight: 600;
      color: #aaa;
      margin-bottom: 0.3rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .path-effects-buttons {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .path-effect-btn {
      border: none;
      background: transparent;
      color: #ccc;
      font-size: 0.75rem;
      cursor: pointer;
      padding: 0.1rem 0.35rem;
      text-align: left;
    }

    .path-effect-btn:hover {
      color: #a0ffa0;
    }

    .path-effect-btn.active {
      color: #4caf50;
      font-weight: 600;
    }

    .path-action-column {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      flex: 1 1 auto;
    }

    .path-action-column-title {
      font-size: 0.7rem;
      font-weight: 600;
      color: #aaa;
      margin-bottom: 0.1rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .path-actions {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .close-path-btn {
      border: none;
      background: transparent;
      color: #ccc;
      font-size: 0.75rem;
      cursor: pointer;
      padding: 0.1rem 0.35rem;
      text-align: left;
    }

    .close-path-btn:hover {
      color: #a0e0ff;
    }

    .undo-path-btn {
      border: none;
      background: transparent;
      color: #ccc;
      font-size: 0.75rem;
      cursor: pointer;
      padding: 0.1rem 0.35rem;
      text-align: left;
    }

    .undo-path-btn:hover {
      color: #ffa0a0;
    }

    .spread-balls-btn {
      border: none;
      background: transparent;
      color: #ccc;
      font-size: 0.75rem;
      cursor: pointer;
      padding: 0.1rem 0.35rem;
      text-align: left;
    }

    .spread-balls-btn:hover {
      color: #a0ffce;
    }

    .toggle-visibility-btn {
      border: none;
      background: transparent;
      color: #ccc;
      font-size: 0.75rem;
      cursor: pointer;
      padding: 0.1rem 0.35rem;
      text-align: left;
    }

    .toggle-visibility-btn:hover {
      color: #ffe08a;
    }

    /* Canvas area: flexes to fill remaining space */
    #canvas {
      flex: 1 1 auto;
      min-width: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: #333; /* overwritten by JS with slider value */
      cursor: crosshair;
    }

    /* Canvas area: flexes to fill remaining space */
    #canvas {
      flex: 1 1 auto;
      min-width: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: #333; /* overwritten by JS with slider value */
      cursor: crosshair;
    }

    /* Palette panel: fixed width */
    #palettePanel {
      flex: 0 0 230px;
      width: 230px;
      min-width: 230px;
      background: #1a1a1a;
      border-left: 1px solid #333;
      padding: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    #paletteHeader {
      font-size: 0.95rem;
      font-weight: 600;
    }

    #paletteList {
      max-height: 320px;
      overflow-y: auto;
      padding-right: 0.25rem;
    }

    .palette-item {
      border-radius: 4px;
      margin-bottom: 0.2rem;
      border: 1px solid transparent;
      cursor: pointer;
      overflow: hidden;
    }

    .palette-item.selected {
      border-color: #ffffffaa;
    }

    .palette-preview {
      display: flex;
      height: 16px;
      width: 100%;
    }

    .palette-color-block {
      flex: 1 1 auto;
    }

    #selectedPaletteHeader {
      font-size: 0.85rem;
      font-weight: 600;
      border-top: 1px solid #333;
      padding-top: 0.4rem;
    }

    #colorSwatchList {
      flex: 1 1 auto;
      overflow-y: auto;
      padding-right: 0.25rem;
    }

    .color-swatch {
      height: 22px;
      border-radius: 2px;
      margin-bottom: 4px;
      border: 2px solid transparent;
      cursor: pointer;
    }

    .color-swatch.selected {
      border-color: #ffffffaa;
    }

    .no-palettes {
      font-size: 0.8rem;
      opacity: 0.6;
      font-style: italic;
    }

    #ballSizeContainer {
      margin-top: 0.4rem;
      font-size: 0.85rem;
    }

    #ballSizeContainer label {
      display: grid;
      grid-template-columns: 70px minmax(0, 1fr) 40px;
      column-gap: 0.3rem;
      align-items: center;
    }

    .slider-label {
      white-space: nowrap;
    }

    #ballSizeSlider {
      width: 100%;
      min-width: 0;
      max-width: 100%;
    }

    #ballSizeValue {
      min-width: 32px;
      text-align: right;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button id="launchBtn">Launch Ball</button>
    <button id="editPathBtn">Edit Paths</button>
    <button id="editBallsBtn">Edit Balls</button>

    

    <label>
      Background:
      <input
        type="range"
        id="bgSlider"
        min="0"
        max="255"
        step="1"
        value="50" />
    </label>

    <div id="hint">
      Draw paths, launch balls, have fun!
    </div>
    <div id="fpsCounter">FPS: 0</div>
  </div>

  <div id="main">
    <div id="pathPanel">
      <div id="pathPanelHeader">
        <span>Paths</span>
        <button id="addPathBtn">+ Path</button>
      </div>
      <div id="pathList"></div>
    </div>

    <canvas id="canvas"></canvas>

    <div id="palettePanel">
      <div id="paletteHeader">Palettes</div>
      <div id="paletteList"></div>
      <div id="selectedPaletteHeader">Colors</div>
      <div id="colorSwatchList"></div>
      <div id="ballSizeContainer">
        <label>
          <span class="slider-label">Ball size:</span>
          <input
            type="range"
            id="ballSizeSlider"
            min="0"
            max="30"
            step="1"
            value="10" />
          <span id="ballSizeValue">10</span>
        </label>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const launchBtn = document.getElementById("launchBtn");
    const editPathBtn = document.getElementById("editPathBtn");
    const editBallsBtn = document.getElementById("editBallsBtn");
    const bgSlider = document.getElementById("bgSlider");
    const ballSizeSlider = document.getElementById("ballSizeSlider");
    const ballSizeValue = document.getElementById("ballSizeValue");
    const fpsCounter = document.getElementById("fpsCounter");

    const addPathBtn = document.getElementById("addPathBtn");
    const pathListEl = document.getElementById("pathList");

    const paletteListEl = document.getElementById("paletteList");
    const colorSwatchListEl = document.getElementById("colorSwatchList");

    // ----- PALETTES -----
    const paletteDefinitions = [
      { id: 1, colors: ["#FFF0F3","#FFCCD5","#FFB3C1","#FF8FA3","#FF758F","#FF4D6D","#C9184A","#A4133C","#800F2F","#590D22"] },
      { id: 2, colors: ["#F8F9FA","#E9ECEF","#DEE2E6","#CED4DA","#ADB5BD","#6C757D","#495057","#343A40","#212529"] },
      { id: 3, colors: ["#80FFDB","#72EFDD","#64DFDF","#56CFE1","#48BFE3","#4EA8DE","#5390D9","#5E60CE","#6930C3","#7400B8"] },
      { id: 4, colors: ["#FFFFFC","#FFC6FF","#BDB2FF","#A0C4FF","#9BF6FF","#CAFFBF","#FDFFB6","#FFD6A5","#FFADAD"] },
      { id: 5, colors: ["#FFBA08","#FAA307","#F48C06","#E85D04","#DC2F02","#D00000","#9D0208","#6A040F","#370617","#03071E"] },
      { id: 6, colors: ["#E63946","#F1FAEE","#A8DADC","#457B9D","#1D3557"] },
      { id: 7, colors: ["#FF0000","#FF8700","#FFD300","#DEFF0A","#A1FF0A","#0AFF99","#0AEFFF","#147DF5","#580AFF","#BE0AFF"] },
      { id: 8, colors: ["#CCFF33","#9EF01A","#70E000","#38B000","#008000","#007200","#006400","#004B23"] },
      { id: 9, colors: ["#E0AAFF","#C77DFF","#9D4EDD","#7B2CBF","#5A189A","#3C096C","#240046","#10002B"] },
      { id: 10, colors: ["#FF595E","#FFCA3A","#8AC926","#1982C4","#6A4C93"] },
      { id: 11, colors: ["#E3F2FD","#BBDEFB","#90CAF9","#64B5F6","#42A5F5","#2196F3","#1E88E5","#1976D2","#1565C0","#0D47A1"] },
      { id: 12, colors: ["#FFEA00","#FFDD00","#FFD000","#FFC300","#FFB700","#FFAA00","#FFA200","#FF9500","#FF8800","#FF7B00"] },
      { id: 13, colors: ["#EDC4B3","#E6B8A2","#DEAB90","#D69F7E","#CD9777","#C38E70","#B07D62","#9D6B53","#8A5A44","#774936"] }
    ];

    let selectedPaletteId = paletteDefinitions[0].id; // start with first palette
    let activeBallColor = paletteDefinitions[0].colors[5]; // 6th color (nice pink) in first palette

    function renderPalettes() {
      paletteListEl.innerHTML = "";
      if (paletteDefinitions.length === 0) {
        const msg = document.createElement("div");
        msg.className = "no-palettes";
        msg.textContent = "No palettes defined.";
        paletteListEl.appendChild(msg);
        return;
      }

      paletteDefinitions.forEach((palette) => {
        const item = document.createElement("div");
        item.className = "palette-item" + (palette.id === selectedPaletteId ? " selected" : "");
        item.dataset.id = palette.id;

        const preview = document.createElement("div");
        preview.className = "palette-preview";

        palette.colors.forEach(color => {
          const seg = document.createElement("div");
          seg.className = "palette-color-block";
          seg.style.backgroundColor = color;
          preview.appendChild(seg);
        });

        item.appendChild(preview);

        item.addEventListener("click", () => {
          selectedPaletteId = palette.id;
          if (palette.colors.length > 0) {
            activeBallColor = palette.colors[0];
          }
          renderPalettes();
          renderColorSwatches();
        });

        paletteListEl.appendChild(item);
      });
    }

    function renderColorSwatches() {
      colorSwatchListEl.innerHTML = "";
      const palette = paletteDefinitions.find(p => p.id === selectedPaletteId);
      if (!palette || palette.colors.length === 0) {
        const msg = document.createElement("div");
        msg.className = "no-palettes";
        msg.textContent = "Select a palette above.";
        colorSwatchListEl.appendChild(msg);
        return;
      }

      palette.colors.forEach(color => {
        const sw = document.createElement("div");
        sw.className =
          "color-swatch" +
          (color.toLowerCase() === activeBallColor.toLowerCase() ? " selected" : "");
        sw.style.backgroundColor = color;
        sw.addEventListener("click", () => {
        if (editBallMode && selectedBalls.length > 0) {
          selectedBalls.forEach(sel => {
            sel.ball.color = color;
          });
        }
        activeBallColor = color;
        renderColorSwatches();
      });
        colorSwatchListEl.appendChild(sw);
      });
    }

    // ----- PATHS / BALLS -----
    const paths = [];
    let nextPathId = 1;
    let selectedPathId = null;

    // ----- EFFECTS -----
    const effects = []; // Array of active effects: [{ type, x, y, age, maxAge, ... }]
    // Track last emission time per ball to control emission frequency
    const ballLastEmission = new Map(); // pathId-ballIndex -> lastEmissionTime

    let canvasWidthCSS = 0;
    let canvasHeightCSS = 0;

    // Speed in pixels per second (all paths/balls share this)
    // Background grayscale value: 0 = black, 255 = white
    let bgGray = parseInt(bgSlider.value, 10) || 50;
    function updateBackground() {
      const g = bgGray;
      const color = `rgb(${g}, ${g}, ${g})`;
      canvas.style.backgroundColor = color;
    }
    updateBackground();

    // Ball size (radius in px)
    let ballRadiusSetting = Number(ballSizeSlider.value);
    function updateBallSizeDisplay() {
      if (ballRadiusSetting <= 0) {
        ballSizeValue.textContent = `?`;
      } else {
        ballSizeValue.textContent = `${ballRadiusSetting}`;
      }
    }
    updateBallSizeDisplay();

    // Edit modes
    let editPathMode = false;
    let editBallMode = false;
    let draggingPath = null;
    let draggingNodeIndex = -1;
    let selectedBalls = [];
    let isSelectingBalls = false;
    let ballSelectionStart = null;
    let ballSelectionCurrent = null;

    function createNewPath(selectAfter = true) {
      const path = {
        id: nextPathId++,
        nodes: [],         // [{ xNorm, yNorm }]
        balls: [],         // [{ dist, color }]
        pointsPx: [],      // [{ x, y }]
        segments: [],      // [{ length, start, x1,y1,x2,y2 }]
        totalLength: 0,
        visible: true,
        ballsVisible: true,
        speed: 400,        // pixels per second (default 400)
        effect: null      // 'ripples' | null (or other effect types in future)
      };
      paths.push(path);
      if (selectAfter) {
        selectedPathId = path.id;
      }
      renderPathList();
      return path;
    }

    function getSelectedPath() {
      if (selectedPathId == null) return null;
      return paths.find(p => p.id === selectedPathId) || null;
    }

    function deletePathById(id) {
      const idx = paths.findIndex(p => p.id === id);
      if (idx === -1) return;

      const path = paths[idx];

      if (selectedBalls.length > 0) {
        selectedBalls = selectedBalls.filter(sel => sel.path !== path);
      }

      // Clean up ball emission tracking for this path
      for (let i = 0; i < path.balls.length; i++) {
        ballLastEmission.delete(`${path.id}-${i}`);
      }

      paths.splice(idx, 1);

      if (paths.length === 0) {
        selectedPathId = null;
      } else if (selectedPathId === id) {
        const newIdx = Math.min(idx, paths.length - 1);
        selectedPathId = paths[newIdx].id;
      }

      renderPathList();
    }

    function renderPathList() {
      pathListEl.innerHTML = "";
      paths.forEach((path, index) => {
        const item = document.createElement("div");
        item.className = "path-item" + (path.id === selectedPathId ? " selected" : "");
        item.dataset.id = path.id;

        const main = document.createElement("div");
        main.className = "path-main";

        const name = document.createElement("div");
        name.className = "path-name";
        name.textContent = `Path ${index + 1}`;

        const meta = document.createElement("div");
        meta.className = "path-meta";
        meta.textContent = `${path.nodes.length} nodes • ${path.balls.length} balls`;

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "delete-path-btn";
        deleteBtn.textContent = "✕";
        deleteBtn.title = "Delete this path";

        const header = document.createElement("div");
        header.className = "path-header";
        header.appendChild(name);
        header.appendChild(deleteBtn);

        main.appendChild(header);
        main.appendChild(meta);

        // Only show actions container for selected path
        if (path.id === selectedPathId) {
          const actionsContainer = document.createElement("div");
          actionsContainer.className = "path-actions-container";

          // Path actions column
          const pathColumn = document.createElement("div");
          pathColumn.className = "path-action-column";

          const pathTitle = document.createElement("div");
          pathTitle.className = "path-action-column-title";
          pathTitle.textContent = "Path";
          pathColumn.appendChild(pathTitle);

          const pathActions = document.createElement("div");
          pathActions.className = "path-actions";

          // Hide/Show button
          const visibilityBtn = document.createElement("button");
          visibilityBtn.className = "toggle-visibility-btn";
          const pathIsVisible = path.visible !== false;
          visibilityBtn.textContent = pathIsVisible ? "Hide" : "Show";
          visibilityBtn.title = pathIsVisible ? "Hide this path" : "Show this path";
          visibilityBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            const currentlyVisible = path.visible !== false;
            path.visible = !currentlyVisible;
            renderPathList();
          });
          pathActions.appendChild(visibilityBtn);

          // Close button (always visible, but no-ops if conditions not met)
          const closeBtn = document.createElement("button");
          closeBtn.className = "close-path-btn";
          closeBtn.textContent = "Close";
          closeBtn.title = "Close this path";
          closeBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            // Only close if path has at least 2 nodes
            if (path.nodes.length >= 2) {
              closeSelectedPath();
            }
            // Otherwise, no-op
          });
          pathActions.appendChild(closeBtn);

          // Undo button (always visible, but no-ops if no nodes)
          const undoBtn = document.createElement("button");
          undoBtn.className = "undo-path-btn";
          undoBtn.textContent = "Undo";
          undoBtn.title = "Remove the most recently placed node";
          undoBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            undoLastNode(path);
          });
          pathActions.appendChild(undoBtn);

          pathColumn.appendChild(pathActions);
          actionsContainer.appendChild(pathColumn);

          // Ball actions column
          const ballsColumn = document.createElement("div");
          ballsColumn.className = "path-action-column";

          const ballsTitle = document.createElement("div");
          ballsTitle.className = "path-action-column-title";
          ballsTitle.textContent = "Balls";
          ballsColumn.appendChild(ballsTitle);

          const ballsActions = document.createElement("div");
          ballsActions.className = "path-actions";

          // Hide/Show balls button
          const ballsVisibilityBtn = document.createElement("button");
          ballsVisibilityBtn.className = "toggle-visibility-btn";
          const ballsAreVisible = path.ballsVisible !== false;
          ballsVisibilityBtn.textContent = ballsAreVisible ? "Hide" : "Show";
          ballsVisibilityBtn.title = ballsAreVisible ? "Hide balls on this path" : "Show balls on this path";
          ballsVisibilityBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            const currentlyVisible = path.ballsVisible !== false;
            path.ballsVisible = !currentlyVisible;
            renderPathList();
          });
          ballsActions.appendChild(ballsVisibilityBtn);

          // Spread button (always visible, but no-ops if conditions not met)
          const spreadBtn = document.createElement("button");
          spreadBtn.className = "spread-balls-btn";
          spreadBtn.textContent = "Spread";
          spreadBtn.title = "Evenly distribute balls along this path";
          spreadBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            // Only spread if there are at least 2 balls and path has valid length
            if (path.balls.length >= 2 && path.totalLength > 0) {
              distributeBallsEvenlyOnPath(path);
              renderPathList();
            }
            // Otherwise, no-op
          });
          ballsActions.appendChild(spreadBtn);

          ballsColumn.appendChild(ballsActions);
          actionsContainer.appendChild(ballsColumn);

          // Speed slider (vertical, to the right of Balls column)
          const speedContainer = document.createElement("div");
          speedContainer.className = "path-speed-slider-container";

          const speedLabel = document.createElement("div");
          speedLabel.className = "path-speed-slider-label";
          speedLabel.textContent = "Speed";
          speedContainer.appendChild(speedLabel);

          const speedSlider = document.createElement("input");
          speedSlider.type = "range";
          speedSlider.className = "path-speed-slider";
          speedSlider.min = "0";
          speedSlider.max = "1000";
          speedSlider.step = "20";
          speedSlider.value = path.speed || 400;
          speedSlider.title = "Ball speed for this path";
          speedContainer.appendChild(speedSlider);

          const speedValue = document.createElement("div");
          speedValue.className = "path-speed-value";
          function updatePathSpeedDisplay() {
            const displaySpeed = (path.speed || 400) / 20;
            speedValue.textContent = `${Math.round(displaySpeed)}`;
          }
          updatePathSpeedDisplay();
          speedContainer.appendChild(speedValue);

          speedSlider.addEventListener("input", (e) => {
            e.stopPropagation();
            path.speed = parseFloat(speedSlider.value) || 0;
            updatePathSpeedDisplay();
          });

          actionsContainer.appendChild(speedContainer);

          main.appendChild(actionsContainer);

          // Effects section
          const effectsSection = document.createElement("div");
          effectsSection.className = "path-effects-section";

          const effectsTitle = document.createElement("div");
          effectsTitle.className = "path-effects-title";
          effectsTitle.textContent = "Effects";
          effectsSection.appendChild(effectsTitle);

          const effectsButtons = document.createElement("div");
          effectsButtons.className = "path-effects-buttons";

          // Ripples effect button
          const ripplesBtn = document.createElement("button");
          ripplesBtn.className = "path-effect-btn" + (path.effect === "ripples" ? " active" : "");
          ripplesBtn.textContent = "Ripples";
          ripplesBtn.title = path.effect === "ripples" ? "Disable ripples effect" : "Enable ripples effect";
          ripplesBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (path.effect === "ripples") {
              path.effect = null;
            } else {
              path.effect = "ripples";
            }
            renderPathList();
          });
          effectsButtons.appendChild(ripplesBtn);

          // Sparks effect button
          const sparksBtn = document.createElement("button");
          sparksBtn.className = "path-effect-btn" + (path.effect === "sparks" ? " active" : "");
          sparksBtn.textContent = "Sparks";
          sparksBtn.title = path.effect === "sparks" ? "Disable sparks effect" : "Enable sparks effect";
          sparksBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (path.effect === "sparks") {
              path.effect = null;
            } else {
              path.effect = "sparks";
            }
            renderPathList();
          });
          effectsButtons.appendChild(sparksBtn);

          // Smoke effect button
          const smokeBtn = document.createElement("button");
          smokeBtn.className = "path-effect-btn" + (path.effect === "smoke" ? " active" : "");
          smokeBtn.textContent = "Smoke";
          smokeBtn.title = path.effect === "smoke" ? "Disable smoke effect" : "Enable smoke effect";
          smokeBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (path.effect === "smoke") {
              path.effect = null;
            } else {
              path.effect = "smoke";
            }
            renderPathList();
          });
          effectsButtons.appendChild(smokeBtn);

          // Bubbles effect button
          const bubblesBtn = document.createElement("button");
          bubblesBtn.className = "path-effect-btn" + (path.effect === "bubbles" ? " active" : "");
          bubblesBtn.textContent = "Bubbles";
          bubblesBtn.title = path.effect === "bubbles" ? "Disable bubbles effect" : "Enable bubbles effect";
          bubblesBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (path.effect === "bubbles") {
              path.effect = null;
            } else {
              path.effect = "bubbles";
            }
            renderPathList();
          });
          effectsButtons.appendChild(bubblesBtn);

          // Streaks effect button
          const streaksBtn = document.createElement("button");
          streaksBtn.className = "path-effect-btn" + (path.effect === "streaks" ? " active" : "");
          streaksBtn.textContent = "Streaks";
          streaksBtn.title = path.effect === "streaks" ? "Disable streaks effect" : "Enable streaks effect";
          streaksBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (path.effect === "streaks") {
              path.effect = null;
            } else {
              path.effect = "streaks";
            }
            renderPathList();
          });
          effectsButtons.appendChild(streaksBtn);

          // Waves effect button
          const wavesBtn = document.createElement("button");
          wavesBtn.className = "path-effect-btn" + (path.effect === "waves" ? " active" : "");
          wavesBtn.textContent = "Waves";
          wavesBtn.title = path.effect === "waves" ? "Disable waves effect" : "Enable waves effect";
          wavesBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (path.effect === "waves") {
              path.effect = null;
            } else {
              path.effect = "waves";
            }
            renderPathList();
          });
          effectsButtons.appendChild(wavesBtn);

          // Lightning effect button
          const lightningBtn = document.createElement("button");
          lightningBtn.className = "path-effect-btn" + (path.effect === "lightning" ? " active" : "");
          lightningBtn.textContent = "Lightning";
          lightningBtn.title = path.effect === "lightning" ? "Disable lightning effect" : "Enable lightning effect";
          lightningBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (path.effect === "lightning") {
              path.effect = null;
            } else {
              path.effect = "lightning";
            }
            renderPathList();
          });
          effectsButtons.appendChild(lightningBtn);

          effectsSection.appendChild(effectsButtons);
          main.appendChild(effectsSection);
        }

        item.appendChild(main);

        item.addEventListener("click", (e) => {
          if (e.target === deleteBtn) {
            return;
          }
          // Don't select path if clicking on action buttons
          if (e.target.closest(".path-actions-container")) {
            return;
          }
          selectedPathId = path.id;
          renderPathList();
        });

        deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          deletePathById(path.id);
        });

        pathListEl.appendChild(item);
      });
      updateEditingUIState();
    }

        function rebuildPathMetricsForPath(path) {
      path.pointsPx = path.nodes.map(node => ({
        x: node.xNorm * canvasWidthCSS,
        y: node.yNorm * canvasHeightCSS
      }));

      path.segments = [];
      path.totalLength = 0;

      if (path.pointsPx.length < 2) {
        return;
      }

      for (let i = 0; i < path.pointsPx.length - 1; i++) {
        const p1 = path.pointsPx[i];
        const p2 = path.pointsPx[i + 1];
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.hypot(dx, dy);

        const seg = {
          length: len,
          start: path.totalLength,
          x1: p1.x,
          y1: p1.y,
          x2: p2.x,
          y2: p2.y
        };

        path.segments.push(seg);
        path.totalLength += len;
      }
    }

    function rebuildAllPathMetrics() {
      for (const path of paths) {
        rebuildPathMetricsForPath(path);
      }
    }

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      canvasWidthCSS = rect.width;
      canvasHeightCSS = rect.height;

      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      rebuildAllPathMetrics();
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function addNodeAtCssPosition(xCss, yCss) {
      if (canvasWidthCSS === 0 || canvasHeightCSS === 0) return;

      let path = getSelectedPath();
      if (!path) {
        path = createNewPath(true);
      }

      const xNorm = xCss / canvasWidthCSS;
      const yNorm = yCss / canvasHeightCSS;

      path.nodes.push({ xNorm, yNorm });
      rebuildPathMetricsForPath(path);
      renderPathList();
    }

    function hitTestNodeGlobal(xCss, yCss) {
      const threshold = 10;
      const thresholdSq = threshold * threshold;
      let best = null;
      let bestDistSq = Infinity;

      for (const path of paths) {
        if (!path.pointsPx || path.pointsPx.length === 0) continue;
        for (let i = 0; i < path.pointsPx.length; i++) {
          const p = path.pointsPx[i];
          const dx = xCss - p.x;
          const dy = yCss - p.y;
          const distSq = dx * dx + dy * dy;
          if (distSq <= thresholdSq && distSq < bestDistSq) {
            bestDistSq = distSq;
            best = { path, nodeIndex: i };
          }
        }
      }

      return best;
    }

    function hitTestBallGlobal(xCss, yCss) {
      const defaultRadius = ballRadiusSetting || 8;
      let best = null;
      let bestDistSq = Infinity;

      for (const path of paths) {
        if (!path.balls || path.balls.length === 0) continue;
        for (let i = 0; i < path.balls.length; i++) {
          const ball = path.balls[i];
          const pos = getPointAlongPathDistance(path, ball.dist);
          if (!pos) continue;

          const r = ball.radius != null ? ball.radius : defaultRadius;
          const threshold = r + 4;
          const thresholdSq = threshold * threshold;

          const dx = xCss - pos.x;
          const dy = yCss - pos.y;
          const distSq = dx * dx + dy * dy;
          if (distSq <= thresholdSq && distSq < bestDistSq) {
            bestDistSq = distSq;
            best = { path, index: i, ball };
          }
        }
      }

      return best;
    }

    function updateNodeAtIndexFromCss(path, i, xCss, yCss) {
      if (i < 0 || i >= path.nodes.length) return;
      if (canvasWidthCSS === 0 || canvasHeightCSS === 0) return;

      const xNorm = Math.min(1, Math.max(0, xCss / canvasWidthCSS));
      const yNorm = Math.min(1, Math.max(0, yCss / canvasHeightCSS));

      path.nodes[i].xNorm = xNorm;
      path.nodes[i].yNorm = yNorm;
      rebuildPathMetricsForPath(path);
    }

    function isPathClosed(path) {
      if (path.nodes.length < 3) return false;
      const first = path.nodes[0];
      const last = path.nodes[path.nodes.length - 1];
      const dx = first.xNorm - last.xNorm;
      const dy = first.yNorm - last.yNorm;
      const distSq = dx * dx + dy * dy;
      const eps = 1e-6;
      return distSq < eps;
    }

    function undoLastNode(path) {
      if (!path || path.nodes.length === 0) return;

      // Remove the last node
      path.nodes.pop();

      // If path is now empty, delete all balls associated with it
      if (path.nodes.length === 0) {
        // Clean up selected balls if any were from this path
        if (selectedBalls.length > 0) {
          selectedBalls = selectedBalls.filter(sel => sel.path !== path);
        }
        // Clear all balls
        path.balls = [];
      }

      // Rebuild path metrics and update display
      rebuildPathMetricsForPath(path);
      renderPathList();
    }

    function closeSelectedPath() {
      const path = getSelectedPath();
      if (!path) return;
      if (path.nodes.length < 2) return;
      if (isPathClosed(path)) return;

      const first = path.nodes[0];
      path.nodes.push({ xNorm: first.xNorm, yNorm: first.yNorm });
      rebuildPathMetricsForPath(path);
      renderPathList();
    }

    function distributeBallsEvenlyOnPath(path) {
      if (!path || !path.balls || path.balls.length === 0) return;
      if (!path.totalLength || path.totalLength <= 0) return;

      const n = path.balls.length;
      if (n === 1) {
        path.balls[0].dist = 0;
        return;
      }

      const step = path.totalLength / n;
      for (let i = 0; i < n; i++) {
        path.balls[i].dist = step * i;
      }
    }

    function getPointAlongPathDistance(path, distance) {
      if (!path.pointsPx || path.pointsPx.length === 0) {
        return null;
      }
      if (path.pointsPx.length === 1 || path.totalLength === 0) {
        return path.pointsPx[0];
      }

      let d = distance % path.totalLength;
      if (d < 0) d += path.totalLength;

      let seg = path.segments[path.segments.length - 1];
      for (let i = 0; i < path.segments.length; i++) {
        const s = path.segments[i];
        if (d <= s.start + s.length) {
          seg = s;
          break;
        }
      }

      const distIntoSeg = d - seg.start;
      const segT = seg.length > 0 ? distIntoSeg / seg.length : 0;

      const x = seg.x1 + (seg.x2 - seg.x1) * segT;
      const y = seg.y1 + (seg.y2 - seg.y1) * segT;

      return { x, y };
    }

    function launchBall() {
      const path = getSelectedPath();
      if (!path) return;
      if (path.nodes.length === 0) return;
      if (editPathMode || editBallMode) return;

      const radius = (ballRadiusSetting <= 0)
        ? Math.round(4 + Math.random() * (30 - 4))
        : ballRadiusSetting;
      path.balls.push({ dist: 0, color: activeBallColor, radius });
      renderPathList();
    }

    function emitEffect(type, x, y, color, direction = null) {
      if (type === "ripples") {
        effects.push({
          type: "ripples",
          x: x,
          y: y,
          age: 0,
          maxAge: 1000, // 1 second lifespan
          radius: 0,
          color: color || "#40e0ff",
          opacity: 0.6
        });
      } else if (type === "sparks") {
        // Create multiple sparks shooting in all directions
        const numSparks = 10;
        const baseSpeed = 150; // pixels per second
        for (let i = 0; i < numSparks; i++) {
          const angle = (Math.PI * 2 * i) / numSparks + (Math.random() - 0.5) * 0.3; // Slight randomness
          const speed = baseSpeed + (Math.random() - 0.5) * 50; // Random speed variation
          effects.push({
            type: "sparks",
            x: x,
            y: y,
            age: 0,
            maxAge: 600, // 0.6 second lifespan
            vx: Math.cos(angle) * speed, // velocity in x direction
            vy: Math.sin(angle) * speed, // velocity in y direction
            color: color || "#40e0ff",
            opacity: 1.0,
            size: 2 + Math.random() * 2 // Random size 2-4px
          });
        }
      } else if (type === "smoke") {
        // Create wispy smoke particles that drift upward
        const numParticles = 3;
        for (let i = 0; i < numParticles; i++) {
          effects.push({
            type: "smoke",
            x: x + (Math.random() - 0.5) * 8, // Slight horizontal spread
            y: y,
            age: 0,
            maxAge: 2000, // 2 second lifespan
            vx: (Math.random() - 0.5) * 20, // Slight horizontal drift
            vy: -30 - Math.random() * 20, // Upward drift, variable speed
            color: color || "#888888",
            opacity: 0.4 + Math.random() * 0.3, // 0.4-0.7
            size: 3 + Math.random() * 4 // Random size 3-7px
          });
        }
      } else if (type === "bubbles") {
        // Create bubbles that rise and pop
        const numBubbles = 1 + Math.floor(Math.random() * 2); // 1-2 bubbles
        for (let i = 0; i < numBubbles; i++) {
          const baseRadius = 4 + Math.random() * 6; // 4-10px radius
          effects.push({
            type: "bubbles",
            x: x + (Math.random() - 0.5) * 10, // Slight horizontal offset
            y: y,
            age: 0,
            maxAge: 1500 + Math.random() * 500, // 1.5-2 second lifespan
            vx: (Math.random() - 0.5) * 15, // Slight horizontal drift
            vy: -40 - Math.random() * 20, // Upward movement
            radius: baseRadius,
            maxRadius: baseRadius * 1.3, // Bubbles grow slightly before popping
            color: color || "#40e0ff",
            opacity: 0.3 + Math.random() * 0.2 // 0.3-0.5
          });
        }
      } else if (type === "streaks") {
        // Create a streak in the direction of travel
        if (direction) {
          const streakLength = 15 + Math.random() * 10; // 15-25px length
          effects.push({
            type: "streaks",
            x: x,
            y: y,
            age: 0,
            maxAge: 300, // 0.3 second lifespan (quick fade)
            endX: x - direction.x * streakLength, // Streak goes backward from direction
            endY: y - direction.y * streakLength,
            color: color || "#40e0ff",
            opacity: 0.8,
            width: 1.5 + Math.random() * 1 // 1.5-2.5px width
          });
        }
      } else if (type === "waves") {
        // Create expanding circular wave with sine pattern
        effects.push({
          type: "waves",
          x: x,
          y: y,
          age: 0,
          maxAge: 1200, // 1.2 second lifespan
          radius: 0,
          color: color || "#40e0ff",
          opacity: 0.7,
          frequency: 3 + Math.random() * 2, // 3-5 waves
          phase: Math.random() * Math.PI * 2 // Random starting phase
        });
      } else if (type === "lightning") {
        // Create branching electrical lightning bolt
        const boltLength = 60 + Math.random() * 40; // 60-100px length
        const angle = Math.random() * Math.PI * 2; // Random angle in all directions (0 to 2π)
        const numSegments = 8 + Math.floor(Math.random() * 5); // 8-12 segments
        const branches = [];
        
        // Create main bolt path
        const segments = [];
        let currentX = x;
        let currentY = y;
        const segmentLength = boltLength / numSegments;
        let currentAngle = angle;
        
        for (let i = 0; i < numSegments; i++) {
          // Jagged path with angle variation
          currentAngle = currentAngle + (Math.random() - 0.5) * 0.4;
          const nextX = currentX + Math.cos(currentAngle) * segmentLength;
          const nextY = currentY + Math.sin(currentAngle) * segmentLength;
          
          segments.push({ x: currentX, y: currentY });
          currentX = nextX;
          currentY = nextY;
          
          // Create branches more frequently (50% chance, and allow more segments)
          if (Math.random() > 0.5 && i > 1 && i < numSegments - 1) {
            const branchLength = 15 + Math.random() * 20; // 15-35px branches
            const branchAngle = currentAngle + (Math.random() - 0.5) * 1.2; // More variation
            branches.push({
              startX: currentX,
              startY: currentY,
              endX: currentX + Math.cos(branchAngle) * branchLength,
              endY: currentY + Math.sin(branchAngle) * branchLength
            });
            
            // Sometimes create a second branch from the same point
            if (Math.random() > 0.6) {
              const branch2Length = 10 + Math.random() * 15;
              const branch2Angle = currentAngle + (Math.random() - 0.5) * 1.2;
              branches.push({
                startX: currentX,
                startY: currentY,
                endX: currentX + Math.cos(branch2Angle) * branch2Length,
                endY: currentY + Math.sin(branch2Angle) * branch2Length
              });
            }
          }
        }
        segments.push({ x: currentX, y: currentY }); // End point
        
        effects.push({
          type: "lightning",
          x: x,
          y: y,
          age: 0,
          maxAge: 200, // 0.2 second lifespan (very quick flash)
          segments: segments,
          branches: branches,
          color: color || "#ffffff",
          opacity: 1.0
        });
      }
      // Add more effect types here in the future
    }

    function updateEffect(effect, dt) {
      if (effect.type === "ripples") {
        // Ripples expand outward
        const progress = effect.age / effect.maxAge;
        effect.radius = progress * 80; // Max radius of 80px
        effect.opacity = 0.6 * (1 - progress); // Fade out over time
      } else if (effect.type === "sparks") {
        // Sparks move outward and fade
        const dtSeconds = dt; // dt is already in seconds
        effect.x += effect.vx * dtSeconds;
        effect.y += effect.vy * dtSeconds;
        const progress = effect.age / effect.maxAge;
        effect.opacity = 1.0 * (1 - progress); // Fade out over time
      } else if (effect.type === "smoke") {
        // Smoke drifts upward and expands/fades
        const dtSeconds = dt;
        effect.x += effect.vx * dtSeconds;
        effect.y += effect.vy * dtSeconds;
        const progress = effect.age / effect.maxAge;
        effect.size += dtSeconds * 5; // Smoke particles expand over time
        effect.opacity = effect.opacity * (1 - progress * 0.5); // Fade out gradually
      } else if (effect.type === "bubbles") {
        // Bubbles rise, grow slightly, and fade
        const dtSeconds = dt;
        effect.x += effect.vx * dtSeconds;
        effect.y += effect.vy * dtSeconds;
        const progress = effect.age / effect.maxAge;
        // Bubbles grow slightly as they rise
        effect.radius = effect.radius + (effect.maxRadius - effect.radius) * progress * 0.3;
        effect.opacity = effect.opacity * (1 - progress); // Fade out over time
      } else if (effect.type === "streaks") {
        // Streaks fade quickly
        const progress = effect.age / effect.maxAge;
        effect.opacity = 0.8 * (1 - progress); // Fade out over time
      } else if (effect.type === "waves") {
        // Waves expand outward
        const progress = effect.age / effect.maxAge;
        effect.radius = progress * 100; // Max radius of 100px
        effect.opacity = 0.7 * (1 - progress); // Fade out over time
      } else if (effect.type === "lightning") {
        // Lightning fades quickly
        const progress = effect.age / effect.maxAge;
        effect.opacity = 1.0 * (1 - progress); // Fade out over time
      }
      // Add more effect update logic here in the future
    }

    function update(dt) {
      if (editPathMode || editBallMode) return;

      const now = performance.now();

      for (const path of paths) {
        if (!path.pointsPx || path.pointsPx.length < 2 || path.totalLength === 0) continue;
        const speed = path.speed || 400; // default to 400 if not set
        const deltaDist = speed * dt;
        
        // Update ball positions
        for (let i = 0; i < path.balls.length; i++) {
          const ball = path.balls[i];
          ball.dist = (ball.dist + deltaDist) % path.totalLength;

          // Emit effects if enabled (even when balls are hidden)
          if (path.effect) {
            const ballKey = `${path.id}-${i}`;
            let lastEmission = ballLastEmission.get(ballKey);
            
            // Determine base interval based on effect type
            let baseInterval = 500; // Default for ripples/sparks
            if (path.effect === "smoke") {
              baseInterval = 300; // Smoke emits more frequently
            } else if (path.effect === "bubbles") {
              baseInterval = 400; // Bubbles emit moderately frequently
            } else if (path.effect === "streaks") {
              baseInterval = 200; // Streaks emit very frequently for smooth trails
            } else if (path.effect === "waves") {
              baseInterval = 600; // Waves emit less frequently
            } else if (path.effect === "lightning") {
              baseInterval = 800; // Lightning emits less frequently (more dramatic)
            }
            
            // If this ball hasn't emitted yet, give it a random initial delay
            if (lastEmission === undefined) {
              lastEmission = now - Math.random() * baseInterval; // Random offset based on interval
              ballLastEmission.set(ballKey, lastEmission);
            }
            const randomVariation = (Math.random() - 0.5) * (baseInterval * 0.4); // ±20% variation
            const emissionInterval = baseInterval + randomVariation;

            if (now - lastEmission >= emissionInterval) {
              const pos = getPointAlongPathDistance(path, ball.dist);
              if (pos) {
                // Calculate direction for streaks (get position slightly ahead)
                let direction = null;
                if (path.effect === "streaks") {
                  const aheadDist = (ball.dist + 5) % path.totalLength;
                  const aheadPos = getPointAlongPathDistance(path, aheadDist);
                  if (aheadPos) {
                    const dx = aheadPos.x - pos.x;
                    const dy = aheadPos.y - pos.y;
                    const len = Math.hypot(dx, dy);
                    if (len > 0) {
                      direction = { x: dx / len, y: dy / len };
                    }
                  }
                }
                emitEffect(path.effect, pos.x, pos.y, ball.color, direction);
                ballLastEmission.set(ballKey, now);
              }
            }
          }
        }
      }

      // Update and age effects
      for (let i = effects.length - 1; i >= 0; i--) {
        const effect = effects[i];
        effect.age += dt * 1000; // age in milliseconds

        if (effect.age >= effect.maxAge) {
          effects.splice(i, 1);
        } else {
          updateEffect(effect, dt);
        }
      }
    }

    function drawEffect(effect) {
      if (effect.type === "ripples") {
        ctx.save();
        ctx.strokeStyle = effect.color;
        ctx.globalAlpha = effect.opacity;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      } else if (effect.type === "sparks") {
        ctx.save();
        ctx.fillStyle = effect.color;
        ctx.globalAlpha = effect.opacity;
        ctx.beginPath();
        ctx.arc(effect.x, effect.y, effect.size || 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      } else if (effect.type === "smoke") {
        // Draw smoke as soft, wispy particles
        ctx.save();
        ctx.fillStyle = effect.color;
        ctx.globalAlpha = effect.opacity;
        ctx.beginPath();
        ctx.arc(effect.x, effect.y, effect.size || 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      } else if (effect.type === "bubbles") {
        // Draw bubbles as circles with a highlight
        ctx.save();
        ctx.strokeStyle = effect.color;
        ctx.fillStyle = effect.color;
        ctx.globalAlpha = effect.opacity;
        ctx.lineWidth = 1.5;
        
        // Draw bubble outline
        ctx.beginPath();
        ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Draw highlight (smaller circle at top-left)
        ctx.globalAlpha = effect.opacity * 0.6;
        ctx.beginPath();
        ctx.arc(effect.x - effect.radius * 0.3, effect.y - effect.radius * 0.3, effect.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      } else if (effect.type === "streaks") {
        // Draw streak as a line in the direction of travel
        ctx.save();
        ctx.strokeStyle = effect.color;
        ctx.globalAlpha = effect.opacity;
        ctx.lineWidth = effect.width || 2;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(effect.x, effect.y);
        ctx.lineTo(effect.endX, effect.endY);
        ctx.stroke();
        ctx.restore();
      } else if (effect.type === "waves") {
        // Draw expanding circular wave with sine wave pattern
        ctx.save();
        ctx.strokeStyle = effect.color;
        ctx.globalAlpha = effect.opacity;
        ctx.lineWidth = 2;
        
        const numPoints = 64; // Number of points to draw the wave
        ctx.beginPath();
        for (let i = 0; i <= numPoints; i++) {
          const angle = (i / numPoints) * Math.PI * 2;
          const baseRadius = effect.radius;
          // Add sine wave variation based on angle and frequency
          const waveOffset = Math.sin(angle * effect.frequency + effect.phase) * 8;
          const radius = baseRadius + waveOffset;
          const x = effect.x + Math.cos(angle) * radius;
          const y = effect.y + Math.sin(angle) * radius;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
        ctx.restore();
      } else if (effect.type === "lightning") {
        // Draw branching lightning bolt with jagged lines
        ctx.save();
        ctx.strokeStyle = effect.color;
        ctx.globalAlpha = effect.opacity;
        ctx.lineWidth = 2;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        
        // Draw main bolt
        if (effect.segments && effect.segments.length > 0) {
          ctx.beginPath();
          ctx.moveTo(effect.segments[0].x, effect.segments[0].y);
          for (let i = 1; i < effect.segments.length; i++) {
            ctx.lineTo(effect.segments[i].x, effect.segments[i].y);
          }
          ctx.stroke();
        }
        
        // Draw branches
        if (effect.branches && effect.branches.length > 0) {
          ctx.lineWidth = 1.5;
          for (const branch of effect.branches) {
            ctx.beginPath();
            ctx.moveTo(branch.startX, branch.startY);
            ctx.lineTo(branch.endX, branch.endY);
            ctx.stroke();
          }
        }
        
        // Draw bright core for extra intensity
        ctx.globalAlpha = effect.opacity * 0.5;
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 1;
        if (effect.segments && effect.segments.length > 0) {
          ctx.beginPath();
          ctx.moveTo(effect.segments[0].x, effect.segments[0].y);
          for (let i = 1; i < effect.segments.length; i++) {
            ctx.lineTo(effect.segments[i].x, effect.segments[i].y);
          }
          ctx.stroke();
        }
        
        ctx.restore();
      }
      // Add more effect rendering here in the future
    }

    function draw() {
      ctx.clearRect(0, 0, canvasWidthCSS, canvasHeightCSS);

      const pathGray = 255 - bgGray;
      const pathColor = `rgb(${pathGray}, ${pathGray}, ${pathGray})`;

      // Draw paths & nodes
      for (const path of paths) {
        if (!path.pointsPx || path.pointsPx.length === 0) continue;

        const pathIsVisibleForDraw = editPathMode || path.visible !== false;
        if (!pathIsVisibleForDraw) continue;

        const isSelected = path.id === selectedPathId;

        // Thin dotted line between nodes
        ctx.save();
        ctx.setLineDash([4, 4]);
        ctx.lineWidth = isSelected ? 1.5 : 1;
        ctx.strokeStyle = pathColor;

        ctx.beginPath();
        ctx.moveTo(path.pointsPx[0].x, path.pointsPx[0].y);
        for (let i = 1; i < path.pointsPx.length; i++) {
          ctx.lineTo(path.pointsPx[i].x, path.pointsPx[i].y);
        }
        ctx.stroke();
        ctx.restore(); // reset dash, lineWidth etc.

        // Node circles
        const baseRadius = 3;
        const editRadius = 6;
        const rNode = editPathMode ? editRadius : baseRadius;

        ctx.fillStyle = pathColor;
        ctx.strokeStyle = pathColor;

        const lastIndex = path.pointsPx.length - 1;

        for (let i = 0; i < path.pointsPx.length; i++) {
          const p = path.pointsPx[i];

          // filled circle
          ctx.beginPath();
          ctx.arc(p.x, p.y, rNode, 0, Math.PI * 2);
          ctx.fill();

          // last node: extra ring
          if (i === lastIndex) {
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(p.x, p.y, rNode + 3, 0, Math.PI * 2);
            ctx.stroke();
          }
        }
      }

      // Draw balls (hidden only in path edit mode or if balls are hidden, but always show in Edit Balls mode)
      if (!editPathMode) {
        for (const path of paths) {
          if (!path.balls || path.balls.length === 0) continue;
          // Show balls in Edit Balls mode even if they're normally hidden
          if (path.ballsVisible === false && !editBallMode) continue;
          for (let i = 0; i < path.balls.length; i++) {
            const ball = path.balls[i];
            const pos = getPointAlongPathDistance(path, ball.dist);
            if (!pos) continue;

            const rBall = ball.radius != null ? ball.radius : ballRadiusSetting;

            ctx.beginPath();
            ctx.fillStyle = ball.color || "#40e0ff";
            ctx.arc(pos.x, pos.y, rBall, 0, Math.PI * 2);
            ctx.fill();

            // highlight selected balls in edit-balls mode
            if (
              editBallMode &&
              selectedBalls.some(sel => sel.path === path && sel.index === i)
            ) {
              ctx.lineWidth = 2;
              ctx.strokeStyle = "#ffffff";
              ctx.beginPath();
              ctx.arc(pos.x, pos.y, rBall + 3, 0, Math.PI * 2);
              ctx.stroke();
            }
          }
        }
      }

      // Draw effects (hidden in edit modes)
      if (!editPathMode && !editBallMode) {
        for (const effect of effects) {
          drawEffect(effect);
        }
      }

      // Draw selection rectangle in ball edit mode
      if (editBallMode && isSelectingBalls && ballSelectionStart && ballSelectionCurrent) {
        const x = Math.min(ballSelectionStart.xCss, ballSelectionCurrent.xCss);
        const y = Math.min(ballSelectionStart.yCss, ballSelectionCurrent.yCss);
        const w = Math.abs(ballSelectionCurrent.xCss - ballSelectionStart.xCss);
        const h = Math.abs(ballSelectionCurrent.yCss - ballSelectionStart.yCss);
        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.8)";
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 2]);
        ctx.strokeRect(x, y, w, h);
        ctx.restore();
      }
    }

    let lastTime = performance.now();
    let fps = 0;

    function loop(now) {
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      update(dt);
      draw();

      const instFps = dt > 0 ? 1 / dt : 0;
      fps = fps * 0.9 + instFps * 0.1;
      if (fpsCounter) {
        fpsCounter.textContent = `FPS: ${fps.toFixed(0)}`;
      }

      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);

    // Pointer helpers
    function getPointerCssPos(event) {
      const rect = canvas.getBoundingClientRect();
      const xCss = event.clientX - rect.left;
      const yCss = event.clientY - rect.top;
      return { xCss, yCss };
    }

    function onPointerDown(event) {
      if (event.button !== 0) return;

      const { xCss, yCss } = getPointerCssPos(event);

      if (editPathMode) {
        const hit = hitTestNodeGlobal(xCss, yCss);
        if (hit) {
          draggingPath = hit.path;
          draggingNodeIndex = hit.nodeIndex;
          canvas.setPointerCapture(event.pointerId);
        }
      } else if (editBallMode) {
        isSelectingBalls = true;
        ballSelectionStart = { xCss, yCss };
        ballSelectionCurrent = { xCss, yCss };
        canvas.setPointerCapture(event.pointerId);
      } else {
        addNodeAtCssPosition(xCss, yCss);
      }
    }

    function onPointerMove(event) {
      const { xCss, yCss } = getPointerCssPos(event);

      if (editPathMode) {
        if (!draggingPath || draggingNodeIndex === -1) return;
        updateNodeAtIndexFromCss(draggingPath, draggingNodeIndex, xCss, yCss);
        return;
      }

      if (editBallMode && isSelectingBalls) {
        ballSelectionCurrent = { xCss, yCss };
      }
    }

    function onPointerUpOrCancel(event) {
      const { xCss, yCss } = getPointerCssPos(event);

      if (editPathMode) {
        if (draggingPath || draggingNodeIndex !== -1) {
          draggingPath = null;
          draggingNodeIndex = -1;
        }
      }

      if (editBallMode && isSelectingBalls && ballSelectionStart && ballSelectionCurrent) {
        const dx = ballSelectionCurrent.xCss - ballSelectionStart.xCss;
        const dy = ballSelectionCurrent.yCss - ballSelectionStart.yCss;
        const distSq = dx * dx + dy * dy;
        const clickThresholdSq = 16; // 4px movement threshold

        if (distSq <= clickThresholdSq) {
          // Treat as a click selection
          const hitBall = hitTestBallGlobal(ballSelectionStart.xCss, ballSelectionStart.yCss);
          if (hitBall) {
            selectedBalls = [hitBall];
          } else {
            selectedBalls = [];
          }
        } else {
          // Rectangle selection
          const minX = Math.min(ballSelectionStart.xCss, ballSelectionCurrent.xCss);
          const maxX = Math.max(ballSelectionStart.xCss, ballSelectionCurrent.xCss);
          const minY = Math.min(ballSelectionStart.yCss, ballSelectionCurrent.yCss);
          const maxY = Math.max(ballSelectionStart.yCss, ballSelectionCurrent.yCss);

          const newSelection = [];
          for (const path of paths) {
            if (!path.balls || path.balls.length === 0) continue;
            for (let i = 0; i < path.balls.length; i++) {
              const ball = path.balls[i];
              const pos = getPointAlongPathDistance(path, ball.dist);
              if (!pos) continue;
              if (pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY) {
                newSelection.push({ path, index: i, ball });
              }
            }
          }
          selectedBalls = newSelection;
        }
      }

      isSelectingBalls = false;
      ballSelectionStart = null;
      ballSelectionCurrent = null;

      try {
        canvas.releasePointerCapture(event.pointerId);
      } catch (e) {
        // ignore
      }
    }

    canvas.addEventListener("pointerdown", onPointerDown);
    canvas.addEventListener("pointermove", onPointerMove);
    canvas.addEventListener("pointerup", onPointerUpOrCancel);
    canvas.addEventListener("pointercancel", onPointerUpOrCancel);
    canvas.addEventListener("pointerleave", onPointerUpOrCancel);

    // Control wiring
    bgSlider.addEventListener("input", () => {
      bgGray = parseInt(bgSlider.value, 10) || 0;
      updateBackground();
    });

    ballSizeSlider.addEventListener("input", () => {
      ballRadiusSetting = Number(ballSizeSlider.value);
      updateBallSizeDisplay();
      if (editBallMode && selectedBalls.length > 0) {
        selectedBalls.forEach(sel => {
          const newRadius = (ballRadiusSetting <= 0)
            ? Math.round(4 + Math.random() * (30 - 4))
            : ballRadiusSetting;
          sel.ball.radius = newRadius;
        });
      }
    });

    launchBtn.addEventListener("click", () => {
      launchBall();
    });

    window.addEventListener("keydown", (event) => {
      // Space: launch ball (if not in edit modes)
      if (event.code === "Space") {
        event.preventDefault();
        launchBall();
        return;
      }

      // Delete: remove selected balls in edit-balls mode
      if ((event.key === "Delete" || event.code === "Delete") && editBallMode) {
        if (selectedBalls.length > 0) {
          const map = new Map();
          for (const sel of selectedBalls) {
            if (!map.has(sel.path)) {
              map.set(sel.path, []);
            }
            map.get(sel.path).push(sel.index);
          }
          for (const [path, indexList] of map.entries()) {
            indexList.sort((a, b) => b - a);
            for (const idx of indexList) {
              if (idx >= 0 && idx < path.balls.length) {
                path.balls.splice(idx, 1);
              }
            }
          }
          selectedBalls = [];
          renderPathList();
        }
        event.preventDefault();
        return;
      }

      // C: close the currently selected path
      if (event.code === "KeyC" || event.key === "c" || event.key === "C") {
        closeSelectedPath();
        event.preventDefault();
      }

      // U: undo last node in currently selected path
      if (event.code === "KeyU" || event.key === "u" || event.key === "U") {
        const path = getSelectedPath();
        if (path) {
          undoLastNode(path);
        }
        event.preventDefault();
      }
    });

    function updateCanvasCursor() {
      if (editPathMode) {
        canvas.style.cursor = "default";
      } else if (editBallMode) {
        canvas.style.cursor = "pointer";
      } else {
        canvas.style.cursor = "crosshair";
      }
    }

    function updateEditingUIState() {
      const editing = editPathMode || editBallMode;

      // Launch/add are disabled in any edit mode
      launchBtn.disabled = editing;
      addPathBtn.disabled = editing;

      // Mode buttons: only the OTHER mode is disabled
      editPathBtn.disabled = editBallMode;
      editBallsBtn.disabled = editPathMode;

      const deleteButtons = pathListEl.querySelectorAll(".delete-path-btn");
      deleteButtons.forEach(btn => {
        btn.disabled = editing;
      });

      const closeButtons = pathListEl.querySelectorAll(".close-path-btn");
      closeButtons.forEach(btn => {
        btn.disabled = editing;
      });

      const spreadButtons = pathListEl.querySelectorAll(".spread-balls-btn");
      spreadButtons.forEach(btn => {
        btn.disabled = editing;
      });

      const visibilityButtons = pathListEl.querySelectorAll(".toggle-visibility-btn");
      visibilityButtons.forEach(btn => {
        btn.disabled = editing;
      });
    }

    editPathBtn.addEventListener("click", () => {
      editPathMode = !editPathMode;
      if (editPathMode) {
        // turning on path edit mode disables ball edit mode
        editBallMode = false;
        selectedBalls = [];
        isSelectingBalls = false;
        ballSelectionStart = null;
        ballSelectionCurrent = null;
        editBallsBtn.textContent = "Edit Balls";
      }
      draggingPath = null;
      draggingNodeIndex = -1;
      editPathBtn.textContent = editPathMode ? "Save Paths" : "Edit Paths";
      editPathBtn.classList.toggle("mode-active", editPathMode);
      editBallsBtn.classList.toggle("mode-active", editBallMode);
      updateEditingUIState();
      updateCanvasCursor();
    });

    editBallsBtn.addEventListener("click", () => {
      editBallMode = !editBallMode;
      if (editBallMode) {
        // turning on ball edit mode disables path edit mode
        editPathMode = false;
        draggingPath = null;
        draggingNodeIndex = -1;
        editPathBtn.textContent = "Edit Paths";
      } else {
        selectedBalls = [];
        isSelectingBalls = false;
        ballSelectionStart = null;
        ballSelectionCurrent = null;
      }
      editBallsBtn.textContent = editBallMode ? "Save Balls" : "Edit Balls";
      editPathBtn.classList.toggle("mode-active", editPathMode);
      editBallsBtn.classList.toggle("mode-active", editBallMode);
      updateEditingUIState();
      updateCanvasCursor();
    });

    addPathBtn.addEventListener("click", () => {
      createNewPath(true);
    });

    // Set initial cursor
    updateCanvasCursor();

    // Initial palette render
    renderPalettes();
    renderColorSwatches();
  </script>
</body>
</html>
